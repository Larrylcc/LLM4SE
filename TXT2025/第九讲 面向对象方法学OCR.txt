面向对象方法学 1◼尽可能模拟人类习惯的思维方式，使开发软件的
方法与过程尽可能接近人类认识世界解决问题的
方法与过程，也就是使描述问题的 问题空间 与实
现解法的 解空间在结构上尽可能一致。
✓客观世界 的应用问题都是由客观世界中的 实体
及实体相互间的 关系构成的。把 实体抽象为问
题域中的对象 。
✓问题空间中，实体具有 作用、责任以及与其它
实体协作。将实体的行为 视对对象操作 。面向对象方法学的基本原则
面向对象方法学 2软件工程
第三部分   面向对象方法学
8.1 面向对象方法学概述
8.2 面向对象的概念
8.3 对象建模技术
8.4  UML 统一建模语言
面向对象方法学 3▪在20世纪 60年代后期出现的 面向对象编程语言
Simula -67中首次引入了类和对象的概念。
◼20世纪 80年代中期起，人们开始注重 面向对象分
析和设计 的研究，逐步形成了面向对象方法学。
◼20世纪 90年代，面向对象方法学 已经成为人们在
开发软件时首选的范型。
◼面向对象技术是当前最好的软件开发技术。8.1 面向对象方法论概述
面向对象方法学 4什么是面向对象
◼Peter Coad 和Edward Yourdon 提出面向对象方法的
概念：
   面向对象 =对象 +分类 +继承 +消息通信
◼用这四个概念开发的软件系统就是 面向对象的软
件系统。
◼如果仅使用对象和消息，称为 基于对象的方法 。
◼如果进一步把所有对象都划分为类，称为 基于类
的方法。
面向对象方法学 5# 面向过程的方法
def feed_animal (animal):
if animal == "lion":
print("喂狮子 ")
elifanimal == "elephant":
print("喂大象 ")
elifanimal == "monkey":
print("喂猴子 ")
else:
print("未知动物 ")
def clean_cage (animal):
print("清洁", animal, " 的笼子 ")
def main():
feed_animal ("lion")
clean_cage ("lion")
if __name__ == "__main__":
main()# 面向对象的方法
class Animal:
def __ init__(self, name):
self.name = name
def feed(self):
print("喂", self.name)
def clean_cage (self):
print("清洁", self.name, " 的笼子 ")
class Lion(Animal):
pass
class Elephant(Animal):
pass
class Monkey(Animal):
pass
def main():
lion = Lion(" 狮子")
lion.feed ()
lion.clean_cage ()
if __name__ == "__main__":
main()
面向对象方法学 6
Car Model 
-title : String 
O.. " 1 
GearBoxType 
-name : String 
-remarks: S打ingGearBO,X 
-gearRatio : float□ 
-cu「rentGear: int 
+ shlftUpO 
+ shift[)ownQ 1 -regi呴通onlNum
-y氐订： int
-licenselNumber: String 
+mo,ve IForwa「d()
+mo四BackwardO
+stopO 
＋田rnR ig htQ
＋田rnLefto
, 
1 1 Engine 
-capacity : float 
-numberOfCylinders: int 
1 I + start() 
+b「ake()
+ accele「ate()
1 1 
Suspension 
-springR沮e:fl遠t
l 
1 1一一含Body 
1 I -n1.1mberOIIDoors: int 
Tire 
-widlh : floiait 
-airPressure : float 1 
| 
Wheel 
-diamete「:float1 
l 
Brake 
4叩e:String 
+ applyQ 
面向对象方法学 7
获得数据进行判断应该
用什么应对方
安面向过程的电梯调度
进行数据的处
理和输出
不是碌后一组数据
勹勹 ［是酶－组 ｀
结束
面向对象方法学 81.面向对象的软件系统是 由对象组成的 ，软件中
的任何元素都是对象，复杂的软件对象由比较
简单的对象组合而成。 计算是通过对象的建立
和对象之间的通信来执行的 。面向对象方法用
对象分解 取代了传统方法的 功能分解 。
2.把所有对象都划分成各种对象类 ，每个对象类
都定义了一组 数据和方法。数据用于表示对象
的静态属性，是对象的状态信息。 方法是允许
施加于该类对象上的操作，为该类所有对象共
享，并不需要为每个对象都复制操作的代码。面向对象方法的要点
面向对象方法学 93.采用继承机制 把若干个对象类组成一个 层次结
构的系统 。在这种层次结构中，通常下层的派
生类（子类）具有和上层的基类（父类）相同
的特性(包括数据和方法 ) 。
4.对象彼此之间仅能 通过传递消息互相联系 。对
象与传统的数据有本质区别，它不是被动地等
待外界对它施加操作，相反，它是进行处理的
主体。必须发消息请求对象主动地执行它的某
些操作，处理它的私有数据，而不能从外界直
接对它的私有数据进行操作。
面向对象方法学 101)与人类习惯的思维方法一致： 使用现实世界的概
念抽象地思考问题，从而自然地解决问题。
✓传统的软件开发方法以 算法为核心 ，把数据和
过程作为相互独立的部分。
✓面向对象开发方法以 对象为核心 ，开发出的软
件系统由对象组成。对象是对现实世界实体的
正确抽象，是数据和操作封装在一起所构成的
统一体。对象之间通过传递消息互相联系，以
模拟现实世界中不同事物彼此之间的联系。面向对象方法学的优点
面向对象方法学 112)稳定性好： 现实世界中的实体是相对稳定的，
以对象为中心构造的软件系统也是比较稳定的。
✓用传统方法所建立起来的软件系统的结构紧
密依赖于系统所要完成的功能 ，当功能需求
发生变化时将引起软件结构的整体修改。这
样的软件系统是不稳定的。
✓面向对象方法基于构造问题领域的 对象模型 ，
以对象为中心构造软件系统。
面向对象方法学 123)可重用性好： 对象是比较理想的模块和可重用的软
件成分。
✓传统的软件重用技术是利用 标准函数库 。
✓面向对象方法中，数据和操作正是作为平等伙
伴出现的对象中的。此外，对象固有的 封装性
和信息隐藏机制 ，使得对象的内部实现与外界
隔离，具有较强的独立性。 对象是比较理想的
模块和可重用的软件成分 。
魔兽争霸
 Dota1
 魔兽 *RPG石
彝',~ 
“c e ... ,;ct'? 寸＇i·
，～泽，较 ！4．
，凡之心父耍屯 ＇．;:'Ji立
J、 .c·-`r、一
尸、~~·.... 
i；年哼七～、
之U
➔ "\'..,,.., 
、“：．..... ···· · 、
•.. ['7 
了
、尸尸七立
面向对象方法学 134)可维护性好
✓稳定性比较好
✓比较容易修改
✓比较容易理解
✓易于测试和调试
5)较易开发大型软件产品
面向对象方法学 14◼对象
◼类
◼实例
◼消息
◼方法8.2 面向对象的概念
◼属性
◼封装
◼继承
◼多态性
◼重载
面向对象方法学 15对 象
▪对象是系统中描述客观事物的实体，是构成系统
的一个基本单元，由一组 属性值和一组对属性进
行操作的 服务组成。
       对象 = 对象名+数据(属性)+操作(行为)
操作 l
操作 3现实勺廿态
s/~犬
2斗
, l 作操
面向对象方法学 16◼什么可以成为对象 ?
在应用领域中有意义的、与所要解决的问题有关
系的任何事物都可以作为对象，它既可以是 具体
的物理实体的抽象 ，也可以是 人为的概念 ，或者
是任何有明确边界和意义的东西 。
  对象可以是 外部实体 、信息结构 、事件、角色、
组织结构 、地点或位置 、操作规程 等。
面向对象方法学 17对象的特点
◼抽象性：对象是 数据抽象 与过程抽象 的综合体。
✓过程抽象 是指当使用某个过程时，无需关心过
程内部的实现细节，只要知道如何调用该过程
以及该过程完成什么功能即可。
✓数据抽象 是指使用结构或记录等方式把某个实
体的数据集中起来，使得使用者能够以单元为
单位使用数据 。
面向对象方法学 18◼封装性：信息隐蔽（使用与实现分开）。把私有
数据完全被封装内部，对外不可见。私有数据的
访问或处理只能通过公有的操作进行。
◼共享性：同一个类中 所有对象共享相同的数据结
构和行为； 同一应用中的 对象通过继承关系，共
享共同的数据结构和行为； 不同应用中 的对象通
过复用，共享数据结构和行为。
◼以数据为中心 ：操作围绕对其数据所需要做的处
理来设置，不设置与这些数据无关的操作。面向
对象范型在 数据抽象 中组织过程抽象 。
面向对象方法学 19◼模块独立性好 ：对象内部各种元素彼此结合得很
紧密，内聚性相当强；由于完成对象功能所需要
的元素(数据和方法 )基本上都被封装在对象内部，
它与外界的联系自然就比较少，因此，对象之间
的耦合通常比较松。
◼分布性：系统的 状态分别保存在各个对象的数据
存储中；解决问题的 控制流包含在各个对象中的
操作内； 算法被分布到各种实体中。
面向对象方法学 20计算机窗口中的三个多边形对象
(50, 60)
(50, 85)(35, 60)
(35, 85)(50, 45)(60, 35)(56, 10)
(46, 37)
(10, 50)(20, 20)
(23, 30)
面向对象方法学 21表示多边形的三个对象draw
move(x, y)
contains?(aPoint)(10, 50)
(20, 20)
(23, 30)triangle
draw
move(x, y)
contains?(aPoint)(46, 37)
(50, 45)
(60, 35)
(56, 10)quadrilateral1
draw
move(x, y)
contains?(aPoint)(35, 60)
(35, 85)
(50, 85)
(50, 60)quadrilateral2
面向对象方法学 22类与实例
▪现实世界中， 分类是人类认识客观世界的基本方
法。把有相似特征的事物归为一类。
▪面向对象方法中，把具有相同属性和服务的 对象
归在一起就形成了 类。类的定义包括一组数据属
性和在数据上的一组合法操作。
▪属于某一个类的各个对象都是该类的 实例，它们
都可使用类中的操作。
▪类定义了各个实例所共有的 数据结构 ，使用类的
构造函数 ，可以在创建该类的 实例时初始化 这个
实例的状态。
面向对象方法学 23由两个四边形对象导出一个类draw
move(x, y)
contains?(aPoint)(46, 37)
(50, 45)
(60, 35)
(56, 10)quadrilateral1
draw
move(x, y)
contains?(aPoint)(35, 60)
(35, 85)
(50, 85)
(50, 60)quadrilateral2
draw
move(x, y)
contains?(aPoint)point1
point2
point3
point4quadrilateral
面向对象方法学 24消息
▪消息是一个对象向另一个对象传递的信息，要
求某个对象执行在定义它的那个类中所定义的
某个操作的规格说明。
▪一个消息由下述三个部分组成：
✓接收消息的对象；
✓消息选择符 (也称为消息名 )；
✓零个或多个变元（参数）。
面向对象方法学 25▪消息的使用类似于函数调用，消息中指定了某一
个实例，一个操作名和一个参数表（可能是空
的）。
   
   quadrilateral1 .move(15, 20)
▪接收消息的对象执行消息中指定的操作，并将形
式参数与消息中相应的变元值结合起来。
面向对象方法学 26属性与方法
◼属性就是类中所定义的数据，它是对客观世界实
体所具有的性质的抽象。类的每个实例都有自己
特有的属性值。
   例quadrilateral1 的四个点
   (46,37)，(50,45)，(60,35)，(56,10)
◼方法就是对象所能执行的操作，也就是 类中所定
义的服务 。方法描述了对象执行操作的算法，响
应消息的方法。
   例quadrilateral. move(  ，)
面向对象方法学 27封装
▪所谓封装就是把某个事物包起来 ，使外界不知
道该事物的具体内容 。面向对象方法中 ，一个
对象是一个不透明的黑盒子 ，封装了数据和实
现操作的 代码。
▪使用一个对象 只需知道它向外界提供的接口 形
式，无须知道它的数据结构细节和实现操作的
算法。通过封装对外界 隐藏了对象的实现细节 。
面向对象方法学 28继承
▪继承是指能够直接获得已有的性质和特征 。面
向对象技术中 ，继承是子类自动地共享基类中
定义的数据和方法的机制 。
▪继承是使用已有的类定义做为基础建立新类的
定义技术 。
◼建立继承结构的好处：
✓易编程、易理解、代码短、结构清晰
✓易修改：共同部分只要在一处修改即可
✓易增加：新类只须描述不同部分
面向对象方法学 29◼怎样建立一个好的继承层次
✓如果某几个类之间具有共性的东西，抽取出
来放在一个 泛化类中，将各个类的特有的东
西放在特化类中分别描述，则可建立起特化
类对泛化类的继承。
✓类可以从父类继承，父类又可以从它的父类
继承，形成多层次的继承结构。
✓当增加一个新类时，不一定在最低层，可能
需要插在中间层，这样可能需要调整原来的
层次结构。
面向对象方法学 30a)建立一个新类 起重车。它的底盘、发动机、轮
胎、驱动装置 等都在已有类 汽车中。关系如右
图所示。新类是已有类的特殊情形。这时直接
让起重车类作为汽车类的子类即可。
起重车
类
汽车类
汽车
载重车
 大轿车
 救火车
 起重车
面向对象方法学 31b)增加一个新类 拖拉机。它的底盘、发动机等与
汽车不同，但 驱动装置 、轮胎等与汽车相同。
✓调整继承结构。建立一个新的一般的 车辆类，
把拖拉机与汽车类的共性放到 车辆类中，拖拉
机与汽车类都成为车辆类的子类。
✓车辆是抽象类，相关操作到子类 汽车找
。
汽车
 拖拉机
车辆汽车
拖拉机
面向对象方法学 32c)另一种情形是在已有类的基础上加入新类，
使得新类成为已有类的泛化类。
✓例如，已经存在 三角形类 ，四边形类 ，想加
入一个多边形类 ，并使之成为 三角形和四边
形类的泛化类。
三角形类
四边形类多
边
形
类
 六边形
多边形
四边形
 三角形
面向对象方法学 33d)前三个情况主要是通过查找（应用领域）类库，
找到可以 原封不动地继承的类 或可以通过调整
继承层次结构继承的类 。但如果在已有的继承
层次中找不到可以继承的已有类，就从新开始
完全独立地建立一个类。
面向对象方法学 34▪如果一个类需要用到多个现有类的特征，可以从
多个类中继承，称为 多继承。
◼例如退休教师 是继承退休者和教师这两个类的某
些特征或行为而得到的一个新类。多继承
退休者
 教师
退休教师
面向对象方法学 35◼两种重载形式：
✓函数重载 是指在同一作用域内的若干个参数
特征不同的函数可以使用相同的函数名字；
✓运算符重载 是指同一个运算符可以施加于不
同类型的操作数上面。
◼当参数特征不同或被操作数的类型不同时，实现
函数的算法或运算符的语义是不相同的。
◼在C++语言中， 编译时决定到底使用函数的哪个
实现代码或算符的具体语义。重载
面向对象方法学 36◼运算符重载举例
a)整数“+”：整数加法
b)浮点数“ +”：浮点数加法
c)字符串“ +”：字符串连接
d)点“+”：两个点的坐标位置分别叠加
面向对象方法学 37多态性
◼多态性是在类等级的不同层次中可以共享一个
方法的名字，然而不同层次中的每个类却各自
按自己的需要来实现这个行为。
◼具有多态的函数或操作在运行时才根据实际的
对象类型，执行相应实现程序的连接，此即 动
态绑定。
  
面向对象方法学 38▪例如，想要在屏幕上画一系列多边形， 多态
性允许发送消息 draw，根据消息接收对象的
类型不同，画出不同的多边形。 draw针对的
是一系列的类型（类族）而不仅仅是一个类
型。
OOOD 勹◊OD
面向对象方法学 39◼C++语言中， 多态性是通过虚函数来实现的。在
类等级不同层次中可以说明 名字、参数特征和返
回值类型都相同 的虚拟成员函数，而不同层次的
类中的虚函数 实现算法各不相同 。
◼动态绑定 把函数调用与目标代码块的连接延迟到
运行时进行（滞后联编），保证在程序执行时实
施与对象  P 连接的操作。如果  P 是矩形类的实
例，则执行与 矩形连接的操作，如果  P 是三角
形类的实例，则执行与 三角形连接的操作。
面向对象方法学 408.3 对象建模技术
▪建模的目的 主要是模型是为了理解事物而对事物
作出的一种抽象。模型由一组图示 符号和组织这
些符号的 规则组成，可用来定义和描述问题域中
的术语和概念。
▪为了减少复杂性。
▪开发复杂的软件系统时，从不同角度抽象出目标系统
的特性，使用精确的表示方法构造系统的模型 ;
▪验证模型是否满足用户对目标系统的需求 ;
▪在设计过程中逐渐把和实现有关的细节加进模型中，
直至最终用程序实现模型。
面向对象方法学 41◼面向对象建模时 ，通常需要建立 3种形式的模型。
从不同侧面描述了所要开发的系统：
✓对象模型 :描述系统的 静态结构 ，定义了做事
情的实体。
✓动态模型 :描述系统的 主要行为 ，明确规定了
在何种状态下接受了什么事件的触发。
✓功能模型 :描述如何实现系统功能，指明了系
统应该“做什么”  。
◼上述 3种模型互相补充，是大系统开发必不可少。
对象模型 始终都是最重要、最基本、最核心的，
为其他两种模型奠定了基础。
面向对象方法学 42◼对象模型 是对模拟客观世界实体的对象以及对
象彼此间的关系的映射，描述了 系统的静态结
构。对象模型为建立动态模型和功能模型，提
供了实质性的框架。
◼为了建立对象模型，需要用适当的建模语言来
表达模型，建模语言由记号和使用记号的规则
组成。
◼通常，使用 UML提供的类图来建立对象模型。
类图描述类及类与类之间的静态关系。类图是
一种静态模型，它是创建其他 UML图的基础。对象模型
面向对象方法学 43金额计算器
金额
累加
找零
重置自动售货机
饮料编号
价格
投入硬币
送出饮料
显示金额
按下按钮
按退币杆
显示售空存量计算器
饮料编号
存量
递减
显示售空
重置
退币杆
退币杆状态
按退币杆
顾客
姓名
硬币
投入硬币
取出饮料选择按钮
按钮状态
按钮灯亮
按钮灯灭
售空灯亮
按下按钮◆
⚫◆
◆ ◆
⚫
顾客按
退币杆购买
顾客按
下按钮属于属于 属于
属于
| 
面向对象方法学 45◼一旦建立起对象模型之后，就需要考察对象的动
态行为。 动态模型 表示瞬时的、行为化的系统的
控制性质，它规定了对象模型中的对象的合法变
化序列。
◼对象的生命周期由许多阶段组成。在每个特定阶
段中，都有适合该对象的一组运行规律和行为规
则。生命周期中的阶段也就是对象的状态。所谓
状态，是对对象属性值的一种抽象。
◼通常，用 UML提供的状态图来描绘对象的 状态、
触发状态转换的 事件以及对象的行为。动态模型
面向对象方法学 46取出饮料
结算找零
扣减存量
完成交易显示售
货机就
绪，所
有灯灭显示
金额
总数饮料
售空
灯亮显示总
额已够
饮料选
择灯亮投入硬币
(有效的 )投入硬币
规定金额金额不足
再投币
按下
饮料
选择
按钮
回到就绪状态回到就绪状态
取消无效硬币
取消
面向对象方法学 47顾客             售货机       金额计算器      选择按钮     存量计算器       售空灯
          投入硬币
                                    累加
                                    总额
          显示总额
                                 金额足够
                                                           灯亮
          选择按钮
                                                       按下按钮
          送出饮料
                                     结算
                                     余额
              找零
                                                                              扣减存量
                                 存量为零
                                                                                                        灯亮
                                  . • 
面向对象方法学 48▪功能模型 表示变化的系统的“功能”性质，它指明
了系统应该“做什么”，因此更直接地反映了用户
对目标系统的需求。
▪在传统的结构化开发方法中，功能模型由一组 数据
流图组成。
▪在面向对象方法中， UML用例图是进行需求分析
和建立功能模型的强有力工具。用例图建立起来的
系统模型称为 用例模型 。用例模型描述的是外部行
为者所理解的系统功能，描述了开发者和用户对需
求规格所达成的共识。功能模型
面向对象方法学 49
«气叫竺一二一
0
只
管理员«include» 
«include» 
、｀、、、飞in ~lude»
~ ` 、、、、~、主
三、、、、、：之、 mc!ud、e:
、、主
0
只二 «extend>>,'
«ext叩，nd"',
', 已一',' - ＿一一一一，＿一
＿一一者皇八g
服务员
面向对象方法学 508.4 统一建模语言 UML
◼UML 是Unified Modeling Language 的缩写。  它
是一种标准的语言，以直观的表述、定义、构造
和文档化软件为主的系统的工作制品。
◼UML聚集了来自下列建模的精髓：
✓数据建模（实体关系图）
✓业务建模  （工作流）
✓对象建模  
✓构件建模
◼UML可用于软件生命周期各个过程，并适用于
各种不同的实现技术。
面向对象方法学 51UML的特点
◼统一标准
✓融合了当前一些流行的面向对象开发方法
的主要概念和技术，成为一种面向对象的
标准化的统一建模语言。
✓提供了标准的面向对象的模型元素的定义
和表示法，有标准的语言工具可用。
✓已成为工业标准化组织 OMG的正式标准。
◼面向对象
✓支持面向对象的主要概念，提供了一批基
本的模型元素的表示图形和方法。
面向对象方法学 52◼可视化，表示能力强大
✓一种图形化语言，系统的逻辑模型和实现模
型都能用 UML的模型图形清晰地表示。
✓可以处理与软件的说明和文档有关的问题。
✓提供了语言的扩展机制，用户可以根据需要
增加定义自己的构造型、标记值和约束等。
✓可用于各种复杂类型的软件系统的建模。
◼独立于过程
✓系统建模语言，独立于开发过程。
面向对象方法学 53◼容易掌握使用
✓概念明确，建模表示法简洁明了，图形结构
清晰，容易掌握使用。
✓着重学习 三个方面的主要内容：
     (1) UML的基本模型元素
     (2) 组织模型元素的规则
     (3) UML语言的公共机制
◼与程序设计语言的关系
✓用Java，C++ 等编程语言可实现一个系统。
✓一些 CASE工具可以根据  UML所建立的系统
模型来产生 Java、C++ 等代码框架 。
面向对象方法学 54UML的定义
◼UML是一种可视化的建模语言。 UML定义有两
个组成部分：
✓语义用自然语言描述；
✓表示法定义了可视化标准表示符号。
◼在语义上，模型是元模型的实例。 UML定义给
出了语法结构的精确定义。
◼使用 UML时，要从不同的角度观察系统，为此
定义了概念“视图”。视图是对系统的模型在某
方面的投影，注重于系统的某个方面。
面向对象方法学 55UML的构成
◼UML的三个主要组成元素
1)基本构造块 （basic building blocks ）
2)组织构造块的 规则（rules）*
3)运用于整个 UML的公共机制 *
   （common mechanisms ）
◼UML包括三种基本构造块 :
1)元素（ things）
2)关系（ relationships ）
3)图（ diagrams）
面向对象方法学 56UML 元素  —结构元素
1)Class（类）
2)Interface（接口）
✓描述了一个类或构件的
服务（操作）集。ISpelling类名
属性
操作
open( )
close( )
move( )
display( )origin
sizeWindow
操作属性类名二
]勹-­,-­',' ,/, ',' 
, ',/ ',' 
, ,, 
, . 
, , 
,, ,, , 
。
面向对象方法学 573)Collaboration （协作）
✓合作完成某个特定任务的一组类及其关联的
集合，用于对用例的实现建模。
4)Use Case（用例）
✓表示系统想要实现的行为，不关心这些行为
是怎样实现的。
Place Order
Order
Management用例协作实现实现
协作用例二 一,,,'/ 
/ 
／
、／
、／
、、／／一一二 ／一二
+/,.,,. -::, -------------<:........、、I
( / 
/ 
、
｀气、~ .... _ 
一 ·_ _ _ _ ＿一一－一－- - 硬，
．圃．多，,a 
面向对象方法学 585)Active Class （主动类）
✓与一般类相同，但它至少拥有一个进程或线
程，故能够启动控制活动。
6)Component （构件）
✓系统中物理的、可替
 代的部件。Orderform
.javasuspend()
flush()EventManager
面向对象方法学 597)Node（节点）
✓系统在运行时存在的物理元素。
数据库
服务器应用
服务器
课程
管理成绩
管理
面向对象方法学 60UML元素  —行为元素
8)Interaction （交互）
◼交互由在特定的上下文环境中共同完成一定任
务的一组对象 之间传递的 消息组成。
◼交互涉及的元素包括消息、动作序列和链。
p:Person :CompanyAssign(development )消息有名对象
匿名对象有名对象
匿名对象消息
、、、、、、、
－
＿
、
、
、
、
、
、勹，，一一一,, ,, ,, ,, ,, ,, ,, ,, ,, ,, ,, 二
,, ,, ,, ,, ,, ,, ,, ,, ,, ,, 
厂 u 、、、
、
、.. 
、、、 、－
面向对象方法学 619)State Machine （状态机）
✓状态机描述了一个对象或一个交互在生存
周期内响应事件所经历的状态序列。
✓状态机涉及的元素包括状态、转换、事件
活动等。
initializing command
idleKeypress
FinishedExit企
面向对象方法学 62UML元素  —分组元素
10)package（包）
✓包是把元素组织成组的机制 ，结构元素、行
为元素甚至其他分组元素都可以放进包内。
✓包不象构件（仅在运行时存在），它纯粹是
概念上的（即它仅在开发时存在）。
用户接口
包
业务对象
包应用包. 
.... .... .... 
多
, 
, _ 
面向对象方法学 63UML元素  —注释元素
11)Note（注释）
✓依附于一个元素或一组元素之上，对其进行
约束或解释的简单符号。
CashAccount
presentValue()See policy8 -5-96.doc 
for details about 
these algorithms./' /' / / ,/ /' 
面向对象方法学 64UML的构成
◼UML的三个主要组成元素
1)基本构造块 （basic building blocks ）
2)组织构造块的 规则（rules）
3)运用于整个 UML的公共机制
   （common mechanisms ）
◼UML包括三种基本构造块 :
1)元素（ things）
2)关系（ relationships ）
3)图（ diagrams ）
面向对象方法学 65UML Relationships （关系）
◼UML中有  4 种关系：
✓依赖
✓关联
✓泛化
✓实现  
◼关系特征：
✓这四种关系是 UML模型中可以包含的基本关
系。
✓它们也有变体。例如，依赖的变体有细化、
跟踪、包含和延伸。
面向对象方法学 661)依赖（ Dependency ）
✓两个元素之间的语义关系，其中目标元素发
生变化会影响源元素的语义。  
✓图中虚线箭头从 源元素指向目标元素 ，表示
源元素依赖于目标元素 。
CourseSchedule
add( c:Course )
remove( c:Course )Course
Iterator<<friend>>一－－－ 叶^ __ 
l 
面向对象方法学 67◼两个类之间的依赖关系可以是：
✓源类访问定义在目标类内部的数据值 ；
✓源类的操作 调用了定义在 目标类的操作 ；
✓源类的返回类或参数是 目标类的实例 ；
◼如果在顺序图中的两个对象存在消息的传送，而
且它们之间没有结构方面的连接，可以在类图上
用依赖关系建模。
◼依赖的变体 包含特定的语义，表明 类之间的关系、
包之间的关系、 用例之间的关系、 对象之间的关
系、建模元素与模型之间的关系等。
面向对象方法学 68◼类之间的依赖关系 可以是：
a.友元依赖  <<friend>>
目标类（如二叉树）视源类（如迭代器）为
友元，允许源类访问目标类的所有私有属性
和操作。
b.导出依赖  <<derive>>
两个类或对象如果存在导出依赖，则表明源
类（如年龄）可以从目标类（如出生年月）
通过计算导出。Iterator BinaryTree<<friend>>
Age BirthDay<<derive>>+----－－－－－－ 寸
二］一一一一一一一一一一 寸
面向对象方法学 69c.细化依赖  <<refine>>
在类图中表示同一模型的不同详细程度的规格
说明，源类比目标类更为详细。
d.实例化依赖  <<instantiate>>
若要强调一个类的对象是由另一个类的对象创
建的，可用实例化依赖。它表明源类创建了目
标类的一个实例。
Array Stack<<instantiate>>
Chessboard 
from optimized <<refine>> 
- - - - - - - - - -> chessboard 
from simple 
l－－一一－－－－－－－－－－ 王二］
面向对象方法学 70e.使用依赖  <<use>>
不加任何修饰的依赖即为使用依赖。也可
用修饰 <<use>>强调源类的语义依赖于目标
类的具有共有可见性的构成的语义。
f.绑定（ Binding）依赖
 这种依赖关系中的目标类是模板类，源类
是从模板实例化的类。Binary Search
Tree Binary Tree<<use>>
<int> Stack <class T> Stack|一一一一一一一一一一寸
I－－－－－－－－ 斗
面向对象方法学 71◼包之间的依赖关系 可以是：
a.访问依赖  <<access>>
它表明源包被赋予了可访问目标包的权限。
b.导入依赖  <<import>>
它表明了源包可以访问目标包里的元素，但各
个包有自己独立的命名空间，这意味着属于不
同包的两个元素可以重名。导入依赖可以使目
标包内的公共可见元素进入源包的命名空间。source target
<<access>>
<<import>>source target<< >> 
－－－－－－－－－－－－－ ➔ 
<<1m >> 
－－－－－－－－－－－－－ ➔ 
面向对象方法学 72◼用例之间的依赖关系 可以是：
a.包含依赖  <<include>>
它表明源用例显式地包含目标用例作为其行
为的一部分。此时将源用例称为 基用例，目
标用例称为 内含用例 。
 如果两个用例之间具有包含依赖关系，则表
明基用例的动作序列中有特定的步骤把内含
用例的动作序列包含进来。
b.扩展依赖  <<extend>>
<<include>> base 
use caseinclusion 
use case
(dndude}} 
夕＇三«；气
((lnclude:《三
<<include>> 
-------------➔ 
面向对象方法学 73它表明源用例扩展了目标用例的行为。此时，源用
例称为扩展用例 ，目标用例称为 基用例。扩展用例
在特定条件下为基用例提供附加的动态行为。例如，
在人机交互过程中出现差错时进行的异常处理即为
扩展动作。
 扩展依赖与包含依赖的区别 在于：如果仅将扩展从
基用例地动作序列中去除，基用例仍然是语义完备
的，即它的执行仍将产生有意义的结果。而包含依
赖则不然。base 
use case
<<extend>>extension 
use case<< d>> +-------------
面向对象方法学 74
．广一 System Boundary 
Association I 
I 十
l System ., 
Extension Point 
、: Older Foocl 
＼之”:一Ionpoln也«Exte吵＞三卜-+-UseCase - - - - - - - - - - - - 心rWioe
Waiter 
血
I S印"leFood 勹I O心n寻Ionpoln也
Actor 氓orde rr也咄
'、... 
<<Exte吵;,, cf 三
: Eat Food 
-«氐一＞－三
Pat兀m
: 已Pay虹 Foody 0血n各Ionpoln也 －<<Exte> - 三
穷forWim
C丑sh:ill:r
Extend _ 
面向对象方法学 75◼对象之间的依赖关系 可以是：
a.转换依赖  <<become>>
当需要在交互图上表示对象状态的转换时可
以用转换依赖。主要强调 由于消息而导致对
象状态的改变 。转换依赖连接的目标对象和
源对象是同一个对象。
b.调用依赖  <<call>>
当需要在交互图或对象图上显式强调对象之
间或操作之间的调用关系时要用调用依赖。
它表明源对象引用了目标对象的操作，或源
操作引用了目标操作。
面向对象方法学 76c.复制依赖  <<copy>>
为了在交互图或活动图上描述对象复制的动
作可以采用复制依赖。它连接两个对象，目
标对象是源对象的完全相同而又独立的副本。
d.发送依赖  <<send>>
它连接一个对象（在源端）和一个消息（在
目标端），表明源对象在交互过程中发送了
一个消息，可以用在状态机的描述中。
 它针对内嵌有状态机的对象，可用来描述如
何通过发送信号以产生某种事件的动作。
面向对象方法学 77◼建模元素与模型之间的依赖关系 是：
a.回溯依赖  <<trace>>
它连接两个模型元素，表明目标是源的历史
上的前驱。如交互和协作就是从用例导出的。
面向对象方法学 782)关联（ Association ）
✓关联是一种结构关系，它描述一组链，这些
链是类之间或类与接口之间 的连接。通过这
种连接，一个对象可以访问另一个对象的属
性或调用另一个对象的操作。
✓关联是双向的，其中的角色代表一个类的对
象在另一个类中的存在。
✓聚合（ aggregation ）是一种特殊类型的关联，
它描述了整体和部分间的结构关系。employer employee0..1 *
面向对象方法学 79✓聚合关系在整体端有一个菱形作为标记。
✓复合聚合（ composite aggregate ）是一种特
殊的聚合关系，它表明整体对象与部分对象
具有相同的生存周期。
   复合聚合 ,双向导航
0..*0..1
0..*整体 类名
部分  类名 2 部分 类名 1聚合,单向导航0..1
面向对象方法学 80

面向对象方法学 81✓角色的重复度（ Multiplicity ） 
    表明角色在关联关系中出现的次数。如 1，0..1，
1..*，*等。
✓导航（ navigation ）
 一般默认关联关系是双向的，而导航则限制关联
关系到一个方向。在图中用箭头指明方向。
company department1 1..*
面向对象方法学 82✓限定关联（ qualification ）
 如教师与学生的关系由课程的标识决定。
teacher student
1
*教师教课nCourseID
course学生选课教师教学生
*
* 限定类目标类
面向对象方法学 83description
dateHired
salaryjobcompany person1 1..*
employer employee
关联类✓关联类
 关联关系是两个类之间的语义连接。在比较简单
的情况下，关联关系的语义用关联关系的名字来
概括。但在某些情况下，需要对关联关系的语义
做详细的定义、存储和访问，为此可以建立关联
类，描述关联的属性 。
面向对象方法学 843)泛化（ Generalization ）
✓一般化─特殊化的关系（继承）。表明特化
类共享一个或多个泛化类的结构和行为。
✓如果两个类被定义为具有 泛化关系 ，就意
味着在任何泛化类（父类）的对象出现的
地方，都可以用特化类（子类）来代替。
✓继承的多态性表明子类的操作的动态行为
可代替父类的 同名操作 的动态行为。
✓泛化关系的变体： 实现继承 。它规定其中
的子类可继承其父类的结构和行为，但其
可见性成为私有，也不支持父类的接口。
面向对象方法学 85Event
ConsoleWindow DialogBox ControlWindow
open()
close()
move()
display()
handleEvent () 泛化
关联依赖
面向对象方法学 864)实现（ Realization ）
✓类之间的语义关系，其中的一个类元指定
了由另一个类保证执行的契约。
✓两种情况出现实现关系：
     1）在接口和实现它们的类或构件 之间；
     2）在用例和它们的协作 之间。
Place Order
Order
Management用例实现
协作
面向对象方法学 87UML的构成
◼UML的三个主要组成元素
1)基本构造块 （basic building blocks ）
2)组织构造块的 规则（rules）
3)运用于整个 UML的公共机制
   （common mechanisms ）
◼UML包括三种基本构造块 :
1)元素（ things）
2)关系（ relationships ）
3)图（ diagrams）
面向对象方法学 88类
属性
操作对象
属性值
操作接口用例
构件 节点状态机
包 注释
依赖 关联 泛化 实现
聚合 复合模型中主要的图形元素
面向对象方法学 89UML模型的图形
Use Case
DiagramsUse Case
Diagrams
用例图
Scenario
DiagramsScenario
Diagrams
协作图State
DiagramsState
Diagrams
构件图
Component
DiagramsComponent
Diagrams
部署图State
DiagramsState
Diagrams对象图
Scenario
DiagramsScenario
Diagrams
状态图Use Case
DiagramsUse Case
Diagrams
顺序图State
DiagramsState
Diagrams
类图
活动图模型
面向对象方法学 90UML图的作用
◼UML 可以用于 :
✓使用用例（use cases）和参与者（actors）描
述系统的边界和它的主要功能。
✓使用交互图（顺序图、协作图） 具体描述用
例的实现。
✓使用类图表示系统的静态结构。  
✓使用状态图模型化对象的行为。
✓使用构件图和部署图展现系统的物理实现体
系结构。  
✓使用构造型（stereotypes ）扩展建模能力。
面向对象方法学 91用例图（ use case diagram ）
◼用例图展现了系统、参与者（actor）、用例及用
例间的关系 。
◼用例图以可视化的方式表达了系统的需求 ，即该
系统在它的上下文环境中所提供的外部可见服务 。
◼在使用 UML用例图表达需求时 ，必要的文字说明
是不可少的 。
◼系统用方框表示，用于划定系统的 功能范围 ，定
义了系统所具有的功能 。描述该系统功能的用例
置于方框内 ，代表外部实体的行为者置于方框外 。 
面向对象方法学 92
自动售货机系统用例图
面向对象方法学 93用例（ Use Cases ）
◼一个用例是可以被 参与者感受到的、系统的一个
完整的功能 ,即系统完成的一系列动作。
◼用例通过关联与 参与者连接，关联指出一个用例
与哪些行为者交互。
◼用例具有下述特征：
✓用例代表某些用户 可见的功能 ，实现一个具
体的用户目标；
✓用例总是被 参与者启动的，并向 参与者提供
可识别的值；
✓用例必须是完整的。
面向对象方法学 94◼用例代表一类功能而不是使用该功能的某个具
体实例。 用例的实例 是系统的一种实际使用方
法，通常称为 脚本。
    比如在自动售货机系统中， 售货、供货和取
货款都是典型用例。
    一个脚本 ：张三投入硬币购买矿泉水，系统
收到钱后把矿泉水送出来。
   另一脚本 ：李四投币买可乐，但是可乐已卖
完了，于是系统给出提示信息并把钱退还给李
四。
面向对象方法学 95参与者（ Actors）
◼参与者指与系统交互的 人或其他系统 。使用用
例并且与系统交互的任何人或物都是 参与者。
◼参与者代表一种 角色，而不是某个具体的人或
物。一个具体的人可以充当多种不同角色。
  例如：顾客是一个参与者，是系统的用户（角
色），而张三是该角色的具体实例。
◼在用例图中用直线连接 参与者和用例，表示两
者之间交换信息，称为通信联系。 参与者对确
定用例是非常有用的。
面向对象方法学 96用例之间的关系
◼扩展关系 :向一个用例 中添加一些动作后构成了
另一个用例 。后者继承前者的一些行为，把后者
称为扩展用例 。
◼例如，在自动售货机系统中，“售货”是一个基
本的用例，如果顾客购买罐装饮料，售货功能完
成得很顺利。如果顾客要购买用纸杯装的散装饮
料，则不能执行该用例提供的常规动作，而要做
些改动。可以修改售货用例，使之既能提供售罐
装饮料的 常规动作（“售货”用例） 又能提供售
散装饮料的 非常规动作（“售散装饮料”用例）
。
面向对象方法学 97
含扩展和使用关系的用例图
面向对象方法学 98◼使用关系 /包含关系 (Use/Include) :一个用例使用另
一个用例时。如果在若干个用例中有某些相同的
动作，则可以把这些相同的动作提取出来单独构
成一个用例（称为抽象用例）。当某个用例使用
该抽象用例时，就好像这个用例包含了抽象用例
中的所有动作。
◼例如，在自动售货机系统中，“供货”用例需要
去掉机器保险并打开它（“打开机器”用例）和
关上机器并加上保险（“关闭机器”用例）。
面向对象方法学 99
含扩展和使用关系的用例图
面向对象方法学 100◼扩展和使用是泛化关系 的两种不同形式。这两种
关系都意味着从几个用例中抽取那些公共的行为
并放入一个单独的用例中，而这个用例被其他用
例使用或扩展。
◼使用和扩展的目的是不同的：
✓在描述一般行为的变化时采用 扩展关系 。
✓在两个或多个用例中出现重复描述又想避免
这种重复时，可以采用 使用关系 。
面向对象方法学 101创建用例模型
◼面向对象方法学中，需求分析的主要任务是 获
取用例。大部分用例将在项目的需求分析阶段
产生，并且随着开发工作的深入还会发现更多
用例。用例集中的每个用例都是对系统的一个
潜在的需求。
◼创建用例模型 的工作包括：定义系统，寻找参
与者和用例，描述用例，定义用例之间的关系，
确认模型。 寻找参与者和用例是关键 。
◼一些问题列表有助于寻找参与者与用例。一个
用例至少与一个参与者相关联。
面向对象方法学 102UML应用实例
◼某大学用计算机管理的注册系统
     注册管理员 设置一个学期的所有课程信息。一
个课程可以有多个课程选课单。 学生选择 4门主
修课和 2门选修课。当某学生在学期注册了，则
记账系统 （billing）会得到通知，在该学期给该
学生开设账号。学生在注册后一段时间可以使
用系统增加 /撤销所选课程。 老师使用这个系统
接受他们课程的选课名册。注册系统的用户将
得到密码（ password ），用于 登录的确认。
面向对象方法学 103参与者与用例
◼确定参与者以他们的要求：
✓注册管理员（  Registrar ）－ 维护所有
课程信息
✓老师（ Teacher ）－ 要求选课名单
✓学生（ Student ）－ 维护选课表
✓记账系统（  Billing System ）－ 从注
册中心接受记账信息
面向对象方法学 104用例图
◼注册系统的用例图直观地描述了参与者和用例
之间的关系。
Student
Registrar
Teacher
Maintain Schedule
Maintain Curriculum
Request Course Roster
Billing System
面向对象方法学 105用例的规格说明
◼从参与者角度编写，为每个用例建立一个规格
说明，描述用例的事件流。包含在用例执行时
系统必须为参与者提供的各种细节。
◼典型的内容有
✓用例如何开始和结束
✓基本的事件流
✓候补的事件流
✓异常的事件流
面向对象方法学 106Maintain Curriculum 用例的事件流
◼用例开始于注册管理员登录到注册系统并敲入他
的密码时。系统检验此密码是否有效，并提示注
册管理员选择当前学期或下个学期。注册管理员
敲入他期望的学期 。然后系统提示选择他所期望
的活动， 包括：
✓Add：执行增加课程的子事件流。
✓Delete：执行删除课程的子事件流。
✓Review：执行审查所有课程信息的子事件流。
✓Quit：则用例终止。
面向对象方法学 107Maintain Schedule 用例
◼用例允许学生在本学期注册他的课程申请。如果
在本学期开学的一段时间内学生作出 add或drop的
变更，他还可修改和删除他的课程选择。
◼课程目录系统提交一个表格，列出本学期所有的
课程申请。
◼基本事件流：
a)当学生想要注册课程申请或者想要改变他的
已有的选课表时，本用例开始。
面向对象方法学 108b)系统要求学生具体说明他可能会执行的功
能（建立、更新或者删除一个选课表）。
c)一旦学生提交了请求信息，将执行某一个
子流。
✓如果学生选择“ 建立一个选课表”，则
执行一个“ 建立”子事件流的服务。
✓如果学生选择“ 更新一个选课表”，则
执行一个“ 更新”子事件流的服务。
✓如果学生选择“ 删除一个选课表”，则
执行一个“ 删除”子事件流的服务。
面向对象方法学 109建立选课表子事件流
a)系统检索来自课程目录系统的一个有效的课程
申请的列表，并把这个表显示给学生。
b)学生根据这个有效的课程申请列表选择  4 门主
修课申请和  2 门选修课申请。
c)一旦学生作出他的选择，系统为学生建立一个
选课表，包括了这个学生选择的课程申请。
d)执行“提交选课表 ”子事件
面向对象方法学 110交互图
◼用例图描述了系统的外部视图。交互图则描
述了如何通过对象之间的交互实现用例。
◼交互图展现了按一定的目的进行的一种交互，
它由在一个上下文中的一组对象及它们之间
交互的信息组成。
◼交互图有两种类型：
✓顺序图（Sequence diagram ）
✓协作图（Collaboration diagram ）
面向对象方法学 111顺序图（ Sequence Diagram ）
◼顺序图也称为序列图，展现了 一组对象 和由这
组对象收发的消息 ，用于按时间顺序对控制流
建模（对象之间的交互）。
◼对象
❑用矩形框表示，排列在图的顶部。
❑对象的生命线用垂线表示，说明对象在一段
时间内存在。
❑对象可以在交互过程中创建，在交互过程中
撤销。
面向对象方法学 112◼消息
✓用生命线之间的 箭头表示。
✓消息出现的 次序自上而下。
✓消息箭头 可以回到同一条生命线，指明 自调
用，即对象发给自己的消息 。
◼控制焦点
✓用一个瘦高的 矩形表示。
✓表示一个对象执行一个动作所经历的时间段。
✓矩形的顶部表示动作的开始，底部表示动作
的结束（可以由一个返回消息来标记）。
面向对象方法学 113◼顺序图的构造步骤 ：
a)首先，把参加交互的对象放在图的上方 ，横向
排列。通常把发起交互的对象 放在左边 ，较下
级对象依次放在右边 。
b)然后，把这些对象发送和接收的消息纵向按时
间顺序从上到下放置 。
c)这样，就提供了控制流随时间推移的清晰的可
视化轨迹 。
面向对象方法学 114选课的顺序图
: 学生
 : 选课表单 : 课程登记管理器 : 课程目录 : 课程
打开
取课程列表取课程列表
显示课程列表
选择 4门主修课
和2门选修课
把课程加入计划
添加学生重复 4门课
面向对象方法学 115◼边界类    是直接与系统外部实体交互的类，
描述系统与外部（人或其他系统）的接口建模，
其原型为 <<boundary>> 。
◼控制类   是为特定用例的控制行为建模的类，
协调特定于用例的行为所需的事件，其原型为
<<control>> 。
◼实体类    是用来保存或更新某个对象的信息
的类，独立于它的环境。原型为 <<entity>> 。
Control
 Entity
 Actor Boundary
面向对象方法学 116协作图（ Collaboration Diagram ）
◼协作图也称为合作图，展现了 一组对象 ，对象
之间的连接 以及对象收发的消息 。(对象与周围
对象之间的交互，以及它们之间的链接 )。
◼协作图中的协作 不是参与者与系统之间的交互 ，
而是系统内部某一个用例中各个对象之间信息
传递的方式 。
◼消息上所附编号指明执行顺序。
◼协作图提供了在协作对象的 结构组织的上下文
环境中观察控制流的一个清晰的可视化轨迹。
面向对象方法学 117◼协作图的构造步骤：
a)将参加交互的 对象作为图的顶点 。
b)将连接这些对象的 链表示为图的弧 。
c)用对象发送和接收的 消息修饰这些链 。
: Registrar
course form :
CourseForm
theManager :
CurriculumManager
aCourse :
Course
1: set course info
2: process
3: add course
4: new course
面向对象方法学 118类图（ class diagram ）
◼类图描述系统的静态设计视图 ，从系统的逻辑
角度展现了一组类 、接口、协作和它们之间的
关系。
◼在类图中 UML建模元素包括：
✓类及其结构和行为；
✓接口；
✓协作；
✓关联、依赖、泛化关系；
✓多重性和导航指示符；
✓角色名字。
面向对象方法学 119类（ Class）
◼类是具有 共同结构 、共同行为 、共同关系和共
同语义的对象的集合。
◼通过检查在顺序图和协作图中的对象可以发现
类。
◼一个类用间隔为三部分的 矩形描绘。
◼类应当使用领域的术语来命名：
✓应建立命名的标准
✓例如，所有的类都是以大写字母开头的单一
名词
面向对象方法学 120类的例子
RegistrationForm
RegistrationManager
Course
Student
CourseOfferingProfessorScheduleAlgorithm
面向对象方法学 121操作（ Operations ）
◼一个类的行为通过类的各种操作来表达。
◼这些操作可以通过检查交互图来寻找。
registration
formregistration 
manager
3: add course(joe,
math 01)RegistrationManager
addCourse(Student,Course)
面向对象方法学 122属性（ Attributes ）
◼一个类的结构通过它的属性来表达。
◼通过检查类的定义、问题的需求，并参照领域
知识来发现属性。
每个课程选课单有
课程号number 、
地点location 、
时间timeCourseOffering
number
location
time
面向对象方法学 123类的例子
RegistrationForm
RegistrationManager
addStudent(Course, StudentInfo)Course
name
numberCredits
open()
addStudent(StudentInfo)
Student
name
majorCourseOffering
location
open()
addStudent(StudentInfo)Professor
name
tenureStatusScheduleAlgorithm
面向对象方法学 124寻找关系
◼通过检查交互图，以发现关系
✓如果两个对象必须打交道，一定存在沟通
的路径。
Registration 
ManagerMath 101:
Course
3: add student(joe)
CourseRegistrationManager
面向对象方法学 125关系的例子
RegistrationForm
RegistrationManager
addStudent(Course, StudentInfo)Course
name
numberCredits
open()
addStudent(StudentInfo)
Student
name
majorCourseOffering
location
open()
addStudent(StudentInfo)Professor
name
tenureStatusScheduleAlgorithm
面向对象方法学 126多重性和导航的例子
RegistrationForm
RegistrationManager
addStudent(Course, StudentInfo)Course
name
numberCredits
open()
addStudent(StudentInfo)
Student
name
majorCourseOffering
location
open()
addStudent(StudentInfo)Professor
name
tenureStatusScheduleAlgorithm
10..*
0..*1
1
1..*43..10
0..4 1
面向对象方法学 127泛化（继承）的例子
RegistrationUserRegistrationManager
addStudent(Course, StudentInfo)Course
name
numberCredits
open()
addStudent(StudentInfo)
Student
name
majorCourseOffering
location
open()
addStudent(StudentInfo)Professor
name
tenureStatusScheduleAlgorithm
10..*
0..*1
1
1..*43..10
0..4 1RegistrationForm
面向对象方法学 128对象图（ Object Diagram ）
◼对象图展现了一组对象以及它们之间的关系 。
用以详述 、构造和文档化系统中存在的实例以
及它们之间的相互关系 。
◼对象图给出系统的静态设计视图或静态进程视
图。描述了在类图中所建立的事物的 实例的静
态快照。
◼对象图一般包括对象和链 。
◼这种视图主要支持系统的功能需求 ，即系统应
该提供给最终用户的服务 。因而它也用于表示
交互图表示的动态场景的一个静态画面 。
面向对象方法学 129对象图的例子 c: 公司
名称=“研发”d2: 部门 d1: 部门
名称=“销售”
d3: 部门
名称=“打印机销售 ”
: 联系信息
地址 =“清华产业楼 411”p: 人员
姓名=“郑人杰”
雇员标识 =6037
职务=“销售副总 ”经理对象
属性值
匿名对象连接 link
面向对象方法学 130状态迁移图
（ State Transition Diagram ）
◼状态是在对象生存周期中的一个位置。在此位
置满足某种条件 ，执行某种活动 或等待某个事
件。
◼状态迁移图 展现了一个状态机，它由状态、转
移、事件和活动组成。状态迁移图显示了：  
✓一个给定类的生存史；
✓导致状态转移的一系列事件；
✓产生状态变化的一系列活动；
◼状态图关注系统的动态视图。
面向对象方法学 131状态迁移图的例子
Open
entry: Register student
exit: Increment countInitialization
do: Initialize course
Closed
do: Finalize courseCanceled
do: Notify registered studentsAdd Student /
Set count = 0Add student[ count < 10 ]
[ count = 10 ]Cancel
Cancel
Cancel
面向对象方法学 132活动图（ Activity Diagram ）
◼一个活动是一个在状态机内部正在进行的非原
子动作（即可中断的 ） 。 
◼活动图是一种特殊的状态图。其中，
✓大多数的或者全部的状态都是 动作状态 或
者活动状态 ;
✓大多数的或者全部的迁移都是由于源状态
中活动的完成而被触发的。
◼一个活动图着重于描述计算过程或工作流的顺
序的和并发的执行步骤。
面向对象方法学 133按订单供货接订单
开发票
结清订单快速交付 正常交付 收款[紧急订单 ] [非紧急订单 ]分叉起点
变迁
结束
汇合合并活动
分支
面向对象方法学 134活动图的两种使用方式
对工作流建模 对操作建模
实现与系统进行协作的参
与者所观察到的活动把活动图作为流程图
使用，对一个计算的
细节部分建模
适用性 对工作流的建模 对分支、分叉和汇合
状态的建模
内容用于可视化、详述、
构造和文档化开发系
统所涉及的业务过程操作的参数和它的局
部对象
面向对象方法学 135泳道（ swimlanes ）
◼活动图描述发生了什么，但没有说明该活动由谁
来完成。泳道描述了这种关系。
◼泳道用矩形框表示，属于某个泳道的活动放在该
矩形框内，将对象名放在矩形框的顶部，表示泳
道中的活动由该对象负责。
◼两个泳道中活动的各自由不同的对象负责，活动
之间控制权的转移表明对象之间的协作关系。
◼所以泳道可以将活动图的逻辑描述与顺序图、协
作图的责任描述结合起来。
面向对象方法学 136乘客                                                              电梯
按下按钮
电梯移到当前楼层[电梯在当前楼层 ]
[否则 ]
电梯开门
进入电梯
电梯关门
按下目标楼层按钮
开往目标楼层
电梯开门 离开电梯
电梯关门
面向对象方法学 137借阅者                                                            图书馆
在书架上找书[返还 ]
[借阅 ]
排队等待
创建借阅记录
准备下次行动[返还 ][借阅 ]
书放回书架 删除借书记录
[多个 ]
[不多于一个 ]
面向对象方法学 138构件图（  Component diagram ）
◼构件图展现了一组构件之间的组织和依赖 。构
件图描述了系统的静态实现视图 。它与类图相
关，通常把构件映射为一个或多个类 、接口或
协作。 
◼一个构件可能是：  
✓部署构件 ：如动态链接库 (DLL)、二进制可
执行构件、 ActiveX控件、JavaBeans 等，是
形成可执行文件的基础。
✓工作产品构件 ：如数据文件或源代码。是部
署构件的来源。
✓执行构件 ：可运行的构件。
面向对象方法学 139构件图的例子
Course Course
OfferingStudent ProfessorCourse.dllPeople.dll
CourseUserRegister.exe Billing.exe
Billing
System
面向对象方法学 140接口（ interface）
◼接口是一个类或构件提供给其他类或构件的一
组操作。类的变体，其变体关键字是
<<interface>> 。
◼每个接口要指定一个名字，以区分不同的接口。
接口的名字就是类的名字，用字符串表示。
◼构件的接口有两种类型：
◼导入接口（ import interface ）：访问服务
的构件使用导入接口；
◼导出接口（ export interface ）：由提供操
作的构件提供。
面向对象方法学 141部署图（ Deployment Diagram ）
◼部署图展现了在软件过程中存在的 运行处理节
点以及其中的构件的配置 。
◼部署图描述了体系结构的 静态实施视图 ，即描
述系统硬件的物理拓扑结构 （包括网络布局和
构件在网络上的位置 ），以及在此结构上执行
的软件（即运行时软构件在节点中的分布情
况）。
◼它与构件图相关 ，通常一个节点 包含一个或多
个构件。
面向对象方法学 142部署图的例子
RegistrationDatabase
DormLibraryMain
Building
主排课数据
库
宿舍图书馆注册
面向对象方法学 143UML的规则
◼命名  (names)
✓为元素、关系和图起名。如：“ student”。
◼作用域  (scope)
✓把施于类而不是施于实例的 操作和属性说明
为类作用域。相当于 C++静态变量。
订单
getNumber
getNewNumber实例作用域
类作用域
加下划线者
面向对象方法学 144◼可见性  (visibility)
✓对类中任一属性或操作定义存取权限。
✓加前缀： + (公用 )、-(私用 )、# (保护 )
◼完整性   (integrity)
✓保持事物之间联系的正确性和一致性。
✓单个模型是不充分的，应建立互补的模型，
从整体描述软件的蓝图。
✓保持模型与实现的一致性。
◼执行  (execution)
✓通过运行或模拟动态模型，才能真正理解
和领会程序代码的含义是什么。
面向对象方法学 145UML的公共机制
◼规格说明  (specifications)
✓UML的图形表示用来对系统进行可视化，
UML的规格说明用来描述系统的细节。
✓规格说明提供了对构造块的语法和语义的
文字叙述。
✓在增量式建模中，可有两种方式：
先画图，再增加语义到它的规格说明中；
先创建规格说明，或对已完成的系统执行
逆向工程，创建这些规格说明的投影图。
面向对象方法学 146◼修饰  (adornments)
✓对类的描述可以包含其他细节，表示为图
形或文字修饰。
✓UML表示中每一个元素都有一个基本符号，
可将各种修饰细节加到这个符号上。
✓例如，下图是一个带修饰的类。
Transaction
+ execute()
+ roolback()
# priority()
-timestamp()公用操作
保护操作
私用操作
面向对象方法学 147◼通用划分  (common divisions)
✓对类和对象的划分
✓接口和实现的分离
Spellingwizard.dll IUnknown
ISpellingCustomer
name
address
phoneYin:Customer
:Customer
pressman有名 Customer 对象
匿名 Customer 对象
由规格说明指定为
一个 Customer 对象
接口是契约，
实现是契约
的一种实施。
面向对象方法学 148◼扩展机制  (extended mechanisms)
约束  (Constraint)
✓约束可增加新的语义或改变已有的规则。
✓约束用 {…}表明，放在相关元素附近。
妻子
丈夫{或}{安全码 }
性别  : {女, 男}个人经理
银行存款公司
0..10..1多个元素
间的约束简单约束
面向对象方法学 149标记值（ Tagged Value ）
✓用标记值可为 UML的事物增加新的特性。
✓标记值与类的属性不同 。标记值可以看作是元
数据，它的值应用到元素本身，而不是它的实
例。
✓标记值常用来详述与代码生成或配置管理有关
的特性。如指定特定类映射到的编程语言，或
描述一个构件的作者或版本。
✓标记值用 {…(标记 ) = …(值)}表示。
面向对象方法学 150构造型  (Stereotype)
✓如果发现需要一个模型构造，它不在 UML中但
又与 UML的某一成分类似，可以将它看作
UML构造的一个构造型。
✓例如， UML接口是一个类，它只有一些不具有
方法实现和属性的公用操作，它是一种特别的
类，可以定义它为类的构造型。
✓当对节点或类建立构造型时，是通过创建类似
于已有构造块的新构造块来扩展  UML。
✓在UML表示法中可以用 《…》表示构造型。
面向对象方法学 151◼构造型可用于分类和扩充关联、继承关系、类
和构件。例如：
✓类的构造型：边界、控制、实体、实用程序、
异常；
✓继承的构造型： uses和extends；
✓构件的构造型：子系统。
EventQueue
{ version = 3.2
author = Yin }
add()
remove()
flush()《exception 》
Overflow
{Ordered}
Tagged Value
Constraint
Stereotype
面向对象方法学 152◼面向对象方法学 认为，客观世界由对象组成。
任何事物都是对象，每个对象都有自己的内部
状态和运动规律，不同对象彼此间通过消息相
互作用、相互联系，从而构成了我们所要分析
和构造的系统。
◼面向对象方法学 比较自然地模拟了人类认识客
观世界的思维方式， 问题空间和解空间 在结构
上尽可能一致。对于大型软件产品来说，面向
对象范型明显优于结构化范型。使用 面向对象
范型能够开发出稳定性好、可重用性好和可维
护性好的软件。小结
面向对象方法学 153◼用面向对象观点建立系统的模型通常包括： 对
象模型（描述系统静态结构）、 动态模型 （描
述系统控制结构）、以及 功能模型 （描述系统
计算结构）。对象模型是最基本、最核心、最
重要的。
◼统一建模语言 UML是国际对象管理组织 OMG批准
的基于面向对象技术的 标准建模语言 。喷泉模
型是典型的面向对象软件过程模型。
面向对象方法学 154

